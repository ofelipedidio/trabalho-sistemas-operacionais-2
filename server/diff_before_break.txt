[1mdiff --git a/server/include/coms.h b/server/include/coms.h[m
[1mindex 9b160cd..e4d596f 100644[m
[1m--- a/server/include/coms.h[m
[1m+++ b/server/include/coms.h[m
[36m@@ -1,3 +1,5 @@[m
[32m+[m[32m#pragma once[m
[32m+[m
 /******************************************\[m
 * This module contains the code related to *[m
 * the communication between servers.       *[m
[36m@@ -9,13 +11,13 @@[m
 typedef struct {[m
     connection_t inbound_connection;[m
     connection_t outbound_connection;[m
[31m-    metadata_t metadata;[m
 } coms_server_t;[m
 [m
 typedef enum {[m
     req_transaction_start,[m
     req_transaction_end,[m
     req_fetch_metadata,[m
[32m+[m[32m    req_hello,[m
 } request_type_t;[m
 [m
 typedef struct {[m
[36m@@ -27,9 +29,7 @@[m [mtypedef struct {[m
     metadata_t metadata;[m
 } response_t;[m
 [m
[32m+[m[32mbool _coms_sync_execute_request(tcp_reader *reader, tcp_writer *writer, request_t request, response_t *out_response);[m
 [m
[31m-/*[m
[31m- * Gets the metadata from the outbound server[m
[31m- */[m
[31m-void update_metadata(coms_server_t *server);[m
[32m+[m[32mbool coms_thread_init();[m
 [m
[1mdiff --git a/server/include/election.h b/server/include/election.h[m
[1mindex 43d1c69..e4a20a0 100644[m
[1m--- a/server/include/election.h[m
[1m+++ b/server/include/election.h[m
[36m@@ -2,10 +2,11 @@[m
 [m
 #include <cinttypes>[m
 #include <vector>[m
[32m+[m[32m#include <iostream>[m
 [m
 typedef enum {[m
     primary,[m
[31m-    secondary,[m
[32m+[m[32m    backup,[m
 } server_type_t;[m
 [m
 typedef struct {[m
[36m@@ -18,20 +19,23 @@[m [mtypedef struct {[m
     std::vector<server_t> servers;[m
 } metadata_t;[m
 [m
[31m-metadata_t GetMetadata(); //TODO[m
[32m+[m[32mvoid initiateElection();[m
 [m
[31m-void initiateElection(); //TODO[m
[32m+[m[32mserver_t getNextServer(const server_t currentServer);[m
 [m
[31m-void setElected(metadata_t& metadata, server_t& electedServer);[m
[32m+[m[32mvoid sendElectionMessage(server_t targetServer, server_t winningServer);[m
 [m
[31m-void updateElected(server_t& currentServer, server_t& electedServer); //TODO[m
[32m+[m[32mvoid sendElectedMessage(server_t targetServer, server_t electedServer);[m
 [m
[31m-void receiveElectionMessage(metadata_t& metadata, server_t& currentServer, server_t& senderServer);[m
[32m+[m[32mvoid handle_async_election_message(server_t winningServer);[m
 [m
[31m-void receiveElectedMessage(metadata_t& metadata, server_t& currentServer, server_t& electedServer);[m
[32m+[m[32mvoid handle_async_elected_message(server_t electedServer);[m
 [m
[31m-server_t getNextServer(const metadata_t& metadata, const server_t& currentServer);[m
[32m+[m[32mvoid setElected();[m
 [m
[31m-void sendElectionMessage(server_t& targetServer, server_t& winningServer); //TODO[m
[32m+[m[32mbool updateElected(server_t electedServer);[m
[32m+[m
[32m+[m[32mvoid printServer(std::ostream &stream, const server_t server);[m
[32m+[m
[32m+[m[32mbool el_start_thread();[m
 [m
[31m-void sendElectedMessage(server_t& targetServer, server_t& electedServer); //TODO[m
[1mdiff --git a/server/include/state.h b/server/include/state.h[m
[1mindex 548f7d3..327bb08 100644[m
[1m--- a/server/include/state.h[m
[1m+++ b/server/include/state.h[m
[36m@@ -1,42 +1,54 @@[m
 #include "../include/coms.h"[m
 #include <semaphore.h>[m
 [m
[32m+[m[32m// TODO - Didio: implement read-write lock[m
[32m+[m
 typedef struct {[m
[31m-    // Static[m
     server_t current_server;[m
[32m+[m[32m    server_t primary_server;[m
[32m+[m
[32m+[m[32m    sem_t metadata_mutex;[m
[32m+[m[32m    metadata_t metadata;[m
 [m
[31m-    // Dynamic[m
     sem_t coms_server_mutex;[m
     coms_server_t coms_server;[m
[32m+[m
[32m+[m[32m    bool should_stop;[m
 } program_state_t;[m
 [m
[31m-/*[m
[31m- * Initializes the state of the program[m
[31m- */[m
[31m-void state_init();[m
[32m+[m[32m/****************\[m
[32m+[m[32m* Initialization *[m
[32m+[m[32m\****************/[m
[32m+[m[32mvoid state_init(uint32_t ip, uint16_t port, server_type_t type);[m
[32m+[m
[32m+[m[32m/*************\[m
[32m+[m[32m* Should stop *[m
[32m+[m[32m\*************/[m
 [m
[31m-/*[m
[31m- * Acquires the coms_server mutex and returns it[m
[31m- */[m
[32m+[m[32mbool should_stop();[m
[32m+[m
[32m+[m[32m/*************\[m
[32m+[m[32m* Coms server *[m
[32m+[m[32m\*************/[m
 coms_server_t *acquire_coms_server();[m
 [m
[31m-/*[m
[31m- * Releases the coms_server mutex[m
[31m- */[m
 void release_coms_server();[m
 [m
[31m-/*[m
[31m- * Sets the value of coms_server[m
[31m- * Assumes you have the com_server mutex[m
[31m- */[m
 void set_coms_server(coms_server_t *coms_server);[m
 [m
[31m-/*[m
[31m- * Acquires the lock and returns the current server[m
[31m- */[m
[31m-server_t *acquire_current_server();[m
[32m+[m[32m/****************\[m
[32m+[m[32m* Current server *[m
[32m+[m[32m\****************/[m
[32m+[m[32mserver_t *get_current_server();[m
[32m+[m
[32m+[m[32m/*****************\[m
[32m+[m[32m* Primary server *[m
[32m+[m[32m\*****************/[m
[32m+[m[32mserver_t *get_primary_server();[m
[32m+[m
[32m+[m[32m/**********\[m
[32m+[m[32m* Metadata *[m
[32m+[m[32m\**********/[m
[32m+[m[32mmetadata_t *acquire_metadata();[m
 [m
[31m-/*[m
[31m- * Releases the the current server's lock[m
[31m- */[m
[31m-server_t *release_current_server();[m
[32m+[m[32mvoid release_metadata();[m
[1mdiff --git a/server/src/closeable.cpp b/server/src/closeable.cpp[m
[1mindex 69bedbf..89bd05e 100644[m
[1m--- a/server/src/closeable.cpp[m
[1m+++ b/server/src/closeable.cpp[m
[36m@@ -29,6 +29,8 @@[m [mvoid sigpipe_handler(int signal_number) {[m
     std::cerr << "\n[SIGPIPE_HANDLER]Caught SIGPIPE signal (" << signal_number << ")." << std::endl;[m
     std::cout << "INICIA A ELEIÃ‡ÃƒO PFV \n";[m
       [m
[32m+[m[32m    // TODO - Didio: close connection with primary[m
     //closeSocket();[m
     initiateElection();[m
[31m-}[m
\ No newline at end of file[m
[32m+[m[32m}[m
[41m+[m
[1mdiff --git a/server/src/coms.cpp b/server/src/coms.cpp[m
[1mindex 414061f..ac0af52 100644[m
[1m--- a/server/src/coms.cpp[m
[1m+++ b/server/src/coms.cpp[m
[36m@@ -1,33 +1,66 @@[m
 #include "../include/coms.h"[m
 #include <cstdlib>[m
 #include <vector>[m
[32m+[m[32m#include <iterator> // Add this include directive[m
[32m+[m[32m#include <algorithm>[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <asm-generic/errno.h>[m
[32m+[m[32m#include <cstdint>[m
[32m+[m[32m#include <cstdio>[m
[32m+[m[32m#include <cstdlib>[m
[32m+[m[32m#include <iomanip>[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32m#include <optional>[m
[32m+[m[32m#include <pthread.h>[m
[32m+[m[32m#include <sstream>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <sys/socket.h>[m
[32m+[m[32m#include <stdio.h>[m
[32m+[m[32m#include <stdlib.h>[m
[32m+[m[32m#include <string.h>[m
[32m+[m[32m#include <unistd.h>[m
[32m+[m[32m#include <sys/types.h>[m[41m [m
[32m+[m[32m#include <sys/socket.h>[m
[32m+[m[32m#include <netinet/in.h>[m
[32m+[m[32m#include <arpa/inet.h>[m
[32m+[m[32m#include <vector>[m
[32m+[m[32m#include <sys/stat.h>[m
[32m+[m[32m#include <pthread.h>[m
[32m+[m
[32m+[m[32m#include "../include/closeable.h"[m
[32m+[m[32m#include "../include/election.h"[m
[32m+[m[32m#include "../include/state.h"[m
[32m+[m
 [m
 #define coms_exec(expr) \[m
     if (!expr) { \[m
[31m-        return 1; \[m
[32m+[m[32m        return false; \[m
     }[m
 [m
 #define STATUS_OK 0[m
 #define STATUS_INVALID_REQUEST_TYPE 10[m
 #define STATUS_NOT_IMPLEMENTED 11[m
 [m
[31m-bool _coms_sync_execute_request(coms_server_t *server, request_t request, response_t *out_response) {[m
[31m-    tcp_writer writer = server->outbound_connection.writer;[m
[31m-    tcp_reader reader = server->outbound_connection.reader;[m
[32m+[m[32mbool _coms_sync_execute_request(tcp_reader *reader, tcp_writer *writer, request_t request, response_t *out_response) {[m
[32m+[m[32m    server_t *current_server = get_current_server();[m
 [m
     switch (request.type) {[m
         case req_transaction_start:[m
[31m-            coms_exec(write_u8(writer, 12));[m
[32m+[m[32m            coms_exec(write_u8(*writer, 12));[m
             break;[m
         case req_transaction_end:[m
[31m-            coms_exec(write_u8(writer, 13));[m
[32m+[m[32m            coms_exec(write_u8(*writer, 13));[m
             break;[m
         case req_fetch_metadata:[m
[31m-            coms_exec(write_u8(writer, 14));[m
[32m+[m[32m            coms_exec(write_u8(*writer, 14));[m
[32m+[m[32m            break;[m
[32m+[m[32m        case req_hello:[m
[32m+[m[32m            coms_exec(write_u8(*writer, 15));[m
[32m+[m[32m            coms_exec(write_u16(*writer, current_server->port));[m
             break;[m
     }[m
 [m
[31m-    coms_exec(flush(server->outbound_connection.writer));[m
[32m+[m[32m    coms_exec(flush(*writer));[m
 [m
     uint64_t metadata_length;[m
     uint64_t primary_index;[m
[36m@@ -35,80 +68,230 @@[m [mbool _coms_sync_execute_request(coms_server_t *server, request_t request, respon[m
 [m
     switch (request.type) {[m
         case req_transaction_start:[m
[31m-            coms_exec(read_u16(reader, &out_response->status));[m
[32m+[m[32m            coms_exec(read_u16(*reader, &out_response->status));[m
             break;[m
 [m
         case req_transaction_end:[m
[31m-            coms_exec(read_u16(reader, &out_response->status));[m
[32m+[m[32m            coms_exec(read_u16(*reader, &out_response->status));[m
             break;[m
 [m
         case req_fetch_metadata:[m
             out_response->metadata = { .servers = std::vector<server_t>() };[m
[31m-            coms_exec(read_u16(reader, &out_response->status));[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms] [Meta] A1" << std::endl;[m
[32m+[m[32m            coms_exec(read_u16(*reader, &out_response->status));[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms] [Meta] A2 (status = " << out_response->status << ")" << std::endl;[m
             if (out_response->status == STATUS_OK) {[m
[31m-                coms_exec(read_u64(reader, &metadata_length));[m
[31m-                coms_exec(read_u64(reader, &primary_index));[m
[32m+[m[32m                std::cerr << "[DEBUG] [Coms] [Meta] A3" << std::endl;[m
[32m+[m[32m                coms_exec(read_u64(*reader, &metadata_length));[m
[32m+[m[32m                std::cerr << "[DEBUG] [Coms] [Meta] A4" << std::endl;[m
[32m+[m[32m                coms_exec(read_u64(*reader, &primary_index));[m
[32m+[m[32m                std::cerr << "[DEBUG] [Coms] [Meta] A5" << std::endl;[m
                 for (uint64_t i = 0; i < metadata_length; i++) {[m
[31m-                    coms_exec(read_u32(reader, &in_server.ip));[m
[31m-                    coms_exec(read_u16(reader, &in_server.port));[m
[31m-                    in_server.server_type = (i == primary_index) ? primary : secondary;[m
[32m+[m[32m                    std::cerr << "[DEBUG] [Coms] [Meta] A6" << std::endl;[m
[32m+[m[32m                    coms_exec(read_u32(*reader, &in_server.ip));[m
[32m+[m[32m                    std::cerr << "[DEBUG] [Coms] [Meta] A7" << std::endl;[m
[32m+[m[32m                    coms_exec(read_u16(*reader, &in_server.port));[m
[32m+[m[32m                    std::cerr << "[DEBUG] [Coms] [Meta] A*" << std::endl;[m
[32m+[m[32m                    in_server.server_type = (i == primary_index) ? primary : backup;[m
                     out_response->metadata.servers.push_back(in_server);[m
                 }[m
             }[m
             break;[m
[32m+[m[32m        case req_hello:[m
[32m+[m[32m            coms_exec(read_u16(*reader, &out_response->status));[m
[32m+[m[32m            break;[m
     }[m
 [m
     return true;[m
 }[m
 [m
[31m-bool coms_handle_request(coms_server_t *server) {[m
[31m-    tcp_reader reader = server->inbound_connection.reader;[m
[31m-    tcp_writer writer = server->inbound_connection.writer;[m
[31m-[m
[32m+[m[32mbool coms_handle_request(tcp_reader *reader, tcp_writer *writer, server_t server) {[m
[32m+[m[32m    std::cerr << "[DEBUG] [Coms] [Hand] Handling request" << std::endl;[m
     uint8_t request_type;[m
[31m-    coms_exec(read_u8(reader, &request_type));[m
[32m+[m[32m    coms_exec(read_u8(*reader, &request_type));[m
     switch (request_type) {[m
[31m-        // req_transaction_start[m
[32m+[m
         case 12:[m
[31m-            coms_exec(write_u16(writer, STATUS_NOT_IMPLEMENTED));[m
[32m+[m[32m            // req_transaction_start[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms] [Hand] Req = transaction start" << std::endl;[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms] [Hand] Done reading request" << std::endl;[m
[32m+[m[32m            coms_exec(write_u16(*writer, STATUS_NOT_IMPLEMENTED));[m
[32m+[m[32m            coms_exec(flush(*writer));[m
             break;[m
[31m-            // req_transaction_end[m
[32m+[m
         case 13:[m
[31m-            coms_exec(write_u16(writer, STATUS_NOT_IMPLEMENTED));[m
[32m+[m[32m            // req_transaction_end[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms] [Hand] Req = transaction end" << std::endl;[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms] [Hand] Done reading request" << std::endl;[m
[32m+[m[32m            coms_exec(write_u16(*writer, STATUS_NOT_IMPLEMENTED));[m
[32m+[m[32m            coms_exec(flush(*writer));[m
             break;[m
[31m-            // req_fetch_metadata[m
[32m+[m
         case 14:[m
[32m+[m[32m            // req_fetch_metadata[m
             {[m
[31m-                uint64_t length = server->metadata.servers.size();[m
[32m+[m[32m                std::cerr << "[DEBUG] [Coms] [Hand] Req = fetch metadata" << std::endl;[m
[32m+[m[32m                std::cerr << "[DEBUG] [Coms] [Hand] Done reading request" << std::endl;[m
[32m+[m[32m                coms_exec(write_u16(*writer, STATUS_OK));[m
[32m+[m[32m                metadata_t *metadata = acquire_metadata();[m
[32m+[m[32m                uint64_t length = metadata->servers.size();[m
                 uint64_t primary_index = length;[m
                 for (uint64_t i = 0; i < length; i++) {[m
[31m-                    if (server->metadata.servers[i].server_type == primary) {[m
[32m+[m[32m                    if (metadata->servers[i].server_type == primary) {[m
                         primary_index = i;[m
                         break;[m
                     }[m
                 }[m
[31m-                coms_exec(write_u64(writer, length));[m
[31m-                coms_exec(write_u64(writer, primary_index));[m
[32m+[m[32m                coms_exec(write_u64(*writer, length));[m
[32m+[m[32m                coms_exec(write_u64(*writer, primary_index));[m
                 for (uint64_t i = 0; i < length; i++) {[m
[31m-                    coms_exec(write_u32(writer, server->metadata.servers[i].ip));[m
[31m-                    coms_exec(write_u16(writer, server->metadata.servers[i].port));[m
[32m+[m[32m                    coms_exec(write_u32(*writer, metadata->servers[i].ip));[m
[32m+[m[32m                    coms_exec(write_u16(*writer, metadata->servers[i].port));[m
                 }[m
[32m+[m[32m                release_metadata();[m
[32m+[m[32m                coms_exec(flush(*writer));[m
             }[m
             break;[m
[32m+[m
[32m+[m[32m        case 15:[m
[32m+[m[32m            // req_hello[m
[32m+[m[32m            {[m
[32m+[m[32m                std::cerr << "[DEBUG] [Coms] [Hand] Req = hello" << std::endl;[m
[32m+[m[32m                coms_exec(read_u16(*reader, &server.port));[m
[32m+[m[32m                std::cerr << "[DEBUG] [Coms] [Hand] Done reading request" << std::endl;[m
[32m+[m[32m                {[m
[32m+[m[32m                    metadata_t *metadata = acquire_metadata();[m
[32m+[m[32m                    metadata->servers.push_back(server);[m
[32m+[m[32m                    release_metadata();[m
[32m+[m[32m                }[m
[32m+[m[32m                coms_exec(write_u16(*writer, STATUS_OK));[m
[32m+[m[32m                coms_exec(flush(*writer));[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m
         default:[m
[31m-            coms_exec(write_u16(writer, STATUS_INVALID_REQUEST_TYPE));[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms] [Hand] Req = error" << std::endl;[m
[32m+[m[32m            coms_exec(write_u16(*writer, STATUS_INVALID_REQUEST_TYPE));[m
[32m+[m[32m            coms_exec(flush(*writer));[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms] [Hand] Done" << std::endl;[m
             return false;[m
     }[m
[32m+[m[32m    std::cerr << "[DEBUG] [Coms] [Hand] Done" << std::endl;[m
 [m
     return true;[m
 }[m
 [m
[31m-void coms_update_metadata(coms_server_t *server) {[m
[31m-    request_t request;[m
[31m-    request.type = req_fetch_metadata;[m
[31m-    response_t response;[m
[31m-    if (!_coms_sync_execute_request(server, request, &response)) {[m
[31m-        return;[m
[32m+[m[32mtypedef struct {[m
[32m+[m[32m    int listen_sockfd;[m
[32m+[m[32m    struct sockaddr_in server_address;[m
[32m+[m[32m} coms_listener_arguments_t;[m
[32m+[m
[32m+[m[32mvoid *coms_listener_thread(void *args) {[m
[32m+[m[32m    std::cerr << "[DEBUG] [Coms Thread] Thread created" << std::endl;[m
[32m+[m
[32m+[m[32m    struct sockaddr_in server_address;[m
[32m+[m[32m    int listen_sockfd;[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        server_t *current_server = get_current_server();[m
[32m+[m
[32m+[m[32m        int connection_sockfd;[m
[32m+[m[32m        socklen_t client_length;[m
[32m+[m[32m        struct sockaddr_in client_address;[m
[32m+[m
[32m+[m[32m        // Initialize the socket[m
[32m+[m[32m        std::cerr << "[DEBUG] [Coms] Creating socket" << std::endl;[m
[32m+[m[32m        listen_sockfd = socket(AF_INET, SOCK_STREAM, 0);[m
[32m+[m[32m        if (listen_sockfd == -1) {[m
[32m+[m[32m            std::cerr << "aaaaaaaaaaaaaaaaaaaaa1" << std::endl;[m
[32m+[m[32m            exit(1);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Bind the socket[m
[32m+[m[32m        server_address.sin_family = AF_INET;[m
[32m+[m[32m        server_address.sin_port = htons(current_server->port+2);[m
[32m+[m[32m        server_address.sin_addr.s_addr = INADDR_ANY;[m
[32m+[m[32m        bzero(&(server_address.sin_zero), 8);[m
[32m+[m
[32m+[m[32m        std::cerr << "[DEBUG] [Coms] Binding socket" << std::endl;[m
[32m+[m[32m        if (bind(listen_sockfd, (struct sockaddr *) &server_address, sizeof(server_address)) < 0) {[m
[32m+[m[32m            std::cerr << "aaaaaaaaaaaaaaaaaaaaa2" << std::endl;[m
[32m+[m[32m            exit(1);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Setup listen queue[m
[32m+[m[32m        std::cerr << "[DEBUG] [Coms] Listening on socket" << std::endl;[m
[32m+[m[32m        listen(listen_sockfd, 15);[m
[32m+[m
[32m+[m[32m        // Register server socket into the closeable connection list[m
[32m+[m[32m        std::cerr << "[DEBUG] [Coms] Storing socket" << std::endl;[m
[32m+[m[32m        add_connection(listen_sockfd);[m
[32m+[m
[32m+[m[32m        // Prepare arguments for the thread[m
[32m+[m[32m        coms_listener_arguments_t *arguments = (coms_listener_arguments_t*) malloc(sizeof(coms_listener_arguments_t));[m
[32m+[m[32m        if (arguments == NULL) {[m
[32m+[m[32m            fprintf(stderr, "ERROR: Failed to allocate memory for listener_arguments_t (errno = %d) [at file \"" __FILE__ "\", line %d]\n", errno, __LINE__-2);[m
[32m+[m[32m            exit(EXIT_FAILURE);[m
[32m+[m[32m        }[m
[32m+[m[32m        *arguments = {[m
[32m+[m[32m            .listen_sockfd = listen_sockfd,[m
[32m+[m[32m            .server_address = server_address,[m
[32m+[m[32m        };[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    int connection_sockfd;[m
[32m+[m[32m    struct sockaddr_in client_address;[m
[32m+[m[32m    socklen_t client_length;[m
[32m+[m
[32m+[m[32m    // Listen for clients[m
[32m+[m[32m    while (!should_stop()) {[m
[32m+[m[32m        std::cerr << "[DEBUG] [Coms Thread] Waiting for client" << std::endl;[m
[32m+[m[32m        client_length = sizeof(struct sockaddr_in);[m
[32m+[m[32m        connection_sockfd = accept(listen_sockfd, (struct sockaddr *) &client_address, &client_length);[m
[32m+[m[32m        if (connection_sockfd == -1) {[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        std::cerr << "[DEBUG] [Coms Thread] Handling client" << std::endl;[m
[32m+[m[32m        add_connection(connection_sockfd);[m
[32m+[m
[32m+[m[32m        connection_t *connection = conn_new([m
[32m+[m[32m                server_address.sin_addr,[m
[32m+[m[32m                ntohs(server_address.sin_port),[m
[32m+[m[32m                client_address.sin_addr,[m
[32m+[m[32m                ntohs(client_address.sin_port),[m
[32m+[m[32m                connection_sockfd);[m
[32m+[m
[32m+[m[32m        server_t server = {[m
[32m+[m[32m            .ip = client_address.sin_addr.s_addr,[m
[32m+[m[32m            .port = client_address.sin_port,[m
[32m+[m[32m            .server_type = backup,[m
[32m+[m[32m        };[m
[32m+[m
[32m+[m[32m        std::cerr << "[Coms] Received a connection from ";[m
[32m+[m[32m        printServer(std::cerr, server);[m
[32m+[m[32m        std::cerr << std::endl;[m
[32m+[m
[32m+[m[32m        bool error_occurred = false;[m
[32m+[m
[32m+[m[32m        while (!(error_occurred || should_stop())) {[m
[32m+[m[32m            std::cerr << "[DEBUG] [Coms Thread] Handling message (e = " << (error_occurred ? "true" : "false") << ")" << std::endl;[m
[32m+[m[32m            if (!coms_handle_request(&connection->reader, &connection->writer, server)) {[m
[32m+[m[32m                error_occurred = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
     }[m
[32m+[m
[32m+[m[32m    close(listen_sockfd);[m
[32m+[m[32m    pthread_exit(NULL);[m
[32m+[m[32m    return NULL;[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool coms_thread_init() {[m
[32m+[m[32m    // Create the thread[m
[32m+[m[32m    std::cerr << "[DEBUG] [Coms] Creating thread" << std::endl;[m
[32m+[m[32m    pthread_t thread;[m
[32m+[m[32m    pthread_create(&thread, NULL, coms_listener_thread, NULL);[m
[32m+[m[32m    return true;[m
 }[m
 [m
[1mdiff --git a/server/src/election.cpp b/server/src/election.cpp[m
[1mindex 0e5c3f4..714b796 100644[m
[1m--- a/server/src/election.cpp[m
[1m+++ b/server/src/election.cpp[m
[36m@@ -1,84 +1,514 @@[m
[31m-#include "../include/election.h"[m
[31m-#include <iterator> // Add this include directive[m
[32m+[m[32m// TODO - Didio: This file is riddled with horrible, horrible error messages. After testing, they needs to be replaced with actual error handling or, at least, good error messages[m
[32m+[m
[32m+[m[32m#include <iterator>[m
 #include <algorithm>[m
[32m+[m[32m#include <asm-generic/errno.h>[m
[32m+[m[32m#include <cstdint>[m
[32m+[m[32m#include <cstdio>[m
[32m+[m[32m#include <cstdlib>[m
[32m+[m[32m#include <iomanip>[m
 #include <iostream>[m
[32m+[m[32m#include <optional>[m
[32m+[m[32m#include <pthread.h>[m
[32m+[m[32m#include <sstream>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <sys/socket.h>[m
[32m+[m[32m#include <stdio.h>[m
[32m+[m[32m#include <stdlib.h>[m
[32m+[m[32m#include <string.h>[m
[32m+[m[32m#include <unistd.h>[m
[32m+[m[32m#include <sys/types.h>[m[41m [m
[32m+[m[32m#include <sys/socket.h>[m
[32m+[m[32m#include <netinet/in.h>[m
[32m+[m[32m#include <arpa/inet.h>[m
[32m+[m[32m#include <vector>[m
[32m+[m[32m#include <sys/stat.h>[m
[32m+[m[32m#include <pthread.h>[m
[32m+[m
[32m+[m[32m#include "../include/closeable.h"[m
[32m+[m[32m#include "../include/election.h"[m
[32m+[m[32m#include "../include/state.h"[m
 [m
[31m-void initiateElection();[m
[32m+[m[32m#define MESSAGE_ELECTION 10[m
[32m+[m[32m#define MESSAGE_ELECTED 20[m
 [m
[31m-bool comp(const server_t& a, const server_t& b){[m
[32m+[m[32m// INTERNAL[m
[32m+[m[32mbool comp(const server_t a, const server_t b){[m
     if( a.ip > b.ip ) return true;[m
     if( a.ip < b.ip) return false;[m
     return (a.port > b.port);[m
 }[m
 [m
[31m-server_t getNextServer(const metadata_t &metadata, const server_t &currentServer)[m
[31m-{[m
[31m-    if (metadata.servers.size() == 1)[m
[31m-        return currentServer;[m
[32m+[m[32mbool server_eq(const server_t *a, const server_t *b) {[m
[32m+[m[32m    return a->ip == b->ip && a->port == b->port;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid initiateElection() {[m
[32m+[m[32m    // Get current server[m
[32m+[m[32m    server_t *currentServer = get_current_server();[m
[32m+[m[32m    // Get next server[m
[32m+[m[32m    server_t nextServer = getNextServer(*currentServer);[m
[32m+[m[32m    // Send election message to the next server[m
[32m+[m[32m    sendElectionMessage(nextServer, *currentServer);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m * Get the next server from a given server in the ring[m
[32m+[m[32m */[m
[32m+[m[32mserver_t getNextServer(const server_t currentServer) {[m
[32m+[m[32m    // INTERNAL: == is not defined for (const server_t, const server_t)[m
[32m+[m
[32m+[m[32m    // Return value[m
[32m+[m[32m    server_t next_server;[m
[32m+[m
[32m+[m[32m    // Acquire the metadata[m
[32m+[m[32m    metadata_t *metadata = acquire_metadata();[m
[32m+[m[32m    // Critical section[m
[32m+[m[32m    {[m
[32m+[m[32m        // Iterates over the servers to find the index of the current server[m
[32m+[m[32m        std::size_t self = metadata->servers.size();[m
[32m+[m[32m        for (std::size_t i = 0; i < metadata->servers.size(); i++) {[m
[32m+[m[32m            if (server_eq(&metadata->servers[i], &currentServer)) {[m
[32m+[m[32m                self = i;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Check for data consistency[m
[32m+[m[32m        if (self == metadata->servers.size()) {[m
[32m+[m[32m            release_metadata();[m
[32m+[m[32m            fprintf(stderr, "[Consistency fail] Failed to find currentServer in metadata!\n");[m
[32m+[m[32m            exit(EXIT_FAILURE);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Iterate over the servers to find the next non-primary server[m
[32m+[m[32m        for (std::size_t i = 0; i < metadata->servers.size(); i++) {[m
[32m+[m[32m            server_t other = metadata->servers[(self+i) % metadata->servers.size()];[m
[32m+[m[32m            if (other.server_type != primary) {[m
[32m+[m[32m                next_server = other;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Fallback: set next server as the current server[m
[32m+[m[32m        next_server = currentServer;[m
[32m+[m[32m    }[m
[32m+[m[32m    release_metadata();[m
[32m+[m
[32m+[m[32m    return next_server;[m
[32m+[m[32m}[m
 [m
[31m-    auto it = std::find(metadata.servers.begin(), metadata.servers.end(), currentServer);[m
[31m-    it = it == metadata.servers.end() ? metadata.servers.begin() : ++it;[m
[31m-    if(it->server_type == primary)return getNextServer(metadata, *(it));[m
[31m-    return *(it);[m
[31m-    [m
[32m+[m[32m/*[m
[32m+[m[32m * Prints the server to stderr[m
[32m+[m[32m */[m
[32m+[m[32mvoid printServer(std::ostream &stream, const server_t server){[m
[32m+[m[32m    stream << std::hex << server.ip << std::dec << ':' << server.port << "[" << (server.server_type == primary ? "p" : "b") << "]";[m
 }[m
 [m
[31m-void receiveElectionMessage(metadata_t& metadata, server_t& currentServer, server_t& senderServer)[m
[31m-{[m
[31m-    server_t nextServer = getNextServer(metadata, currentServer);[m
[31m-[m
[31m-    if(currentServer.ip == senderServer.ip && currentServer.port == senderServer.port)[m
[31m-        return sendElectedMessage(nextServer, currentServer);[m
[31m-    [m
[31m-    if(comp(currentServer, senderServer))[m
[31m-        return sendElectionMessage(nextServer, currentServer);[m
[31m-    [m
[31m-    sendElectionMessage(nextServer, senderServer);[m
[32m+[m[32m/***************************************\[m
[32m+[m[32m*                                       *[m
[32m+[m[32m*       Outbound message handling       *[m
[32m+[m[32m*                                       *[m
[32m+[m[32m\***************************************/[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m * Send election message to nextServer[m
[32m+[m[32m */[m
[32m+[m[32mvoid sendElectionMessage(server_t nextServer, server_t winningServer) {[m
[32m+[m[32m    // Connect to the next server[m
[32m+[m[32m    connection_t *conn;[m
[32m+[m[32m    {[m
[32m+[m[32m        // Setup[m
[32m+[m[32m        struct sockaddr_in server_addr;[m
[32m+[m[32m        server_addr.sin_family = AF_INET;[m
[32m+[m[32m        server_addr.sin_port = htons(winningServer.port+1);[m
[32m+[m[32m        server_addr.sin_addr = { nextServer.ip };[m
[32m+[m[32m        bzero(&server_addr.sin_zero, 8);[m
[32m+[m
[32m+[m[32m        // Create socket[m
[32m+[m[32m        int sockfd = socket(AF_INET, SOCK_STREAM, 0);[m
[32m+[m[32m        if (sockfd == -1) {[m
[32m+[m[32m            std::cerr << "ERROR: [Election connection init 1] Could not create the socket" << std::endl;[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Connect[m
[32m+[m[32m        int connect_response = connect(sockfd, (struct sockaddr *) (&server_addr), sizeof(struct sockaddr_in));[m
[32m+[m[32m        if (connect_response < 0) {[m
[32m+[m[32m            std::cerr << "ERROR: [Election connection init 1] Could not connect to the server" << std::endl;[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Create connection object[m
[32m+[m[32m        // INTERNAL: the client's fields are set to the server's fields on purpose[m
[32m+[m[32m        // TODO - Didio: figure out how to get client's IP and port[m
[32m+[m[32m        conn = conn_new([m
[32m+[m[32m                server_addr.sin_addr,[m
[32m+[m[32m                ntohs(server_addr.sin_port),[m
[32m+[m[32m                server_addr.sin_addr,[m
[32m+[m[32m                ntohs(server_addr.sin_port),[m
[32m+[m[32m                sockfd);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Send election message[m
[32m+[m[32m    if (!write_u8(conn->writer, MESSAGE_ELECTION)) {[m
[32m+[m[32m        std::cerr << "ERROR 1" << std::endl;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!write_u32(conn->writer, winningServer.ip)) {[m
[32m+[m[32m        std::cerr << "ERROR 2" << std::endl;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!write_u16(conn->writer, winningServer.port)) {[m
[32m+[m[32m        std::cerr << "ERROR 3" << std::endl;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    // Flush writer[m
[32m+[m[32m    if (!flush(conn->writer)) {[m
[32m+[m[32m        std::cerr << "ERROR 4" << std::endl;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
 }[m
 [m
[32m+[m[32m/*[m
[32m+[m[32m * Send elected message to nextServer[m
[32m+[m[32m */[m
[32m+[m[32mvoid sendElectedMessage(server_t nextServer, server_t electedServer) {[m
[32m+[m[32m    // Connect to the next server[m
[32m+[m[32m    connection_t *conn;[m
[32m+[m[32m    {[m
[32m+[m[32m        // Setup[m
[32m+[m[32m        struct sockaddr_in server_addr;[m
[32m+[m[32m        server_addr.sin_family = AF_INET;[m
[32m+[m[32m        server_addr.sin_port = htons(electedServer.port+1);[m
[32m+[m[32m        server_addr.sin_addr = { nextServer.ip };[m
[32m+[m[32m        bzero(&server_addr.sin_zero, 8);[m
[32m+[m
[32m+[m[32m        // Create socket[m
[32m+[m[32m        int sockfd = socket(AF_INET, SOCK_STREAM, 0);[m
[32m+[m[32m        if (sockfd == -1) {[m
[32m+[m[32m            std::cerr << "ERROR: [Election connection init 1] Could not create the socket" << std::endl;[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Connect[m
[32m+[m[32m        int connect_response = connect(sockfd, (struct sockaddr *) (&server_addr), sizeof(struct sockaddr_in));[m
[32m+[m[32m        if (connect_response < 0) {[m
[32m+[m[32m            std::cerr << "ERROR: [Election connection init 1] Could not connect to the server" << std::endl;[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Create connection object[m
[32m+[m[32m        // INTERNAL: the client's fields are set to the server's fields on purpose[m
[32m+[m[32m        // TODO - Didio: figure out how to get client's IP and port[m
[32m+[m[32m        conn = conn_new([m
[32m+[m[32m                server_addr.sin_addr,[m
[32m+[m[32m                ntohs(server_addr.sin_port),[m
[32m+[m[32m                server_addr.sin_addr,[m
[32m+[m[32m                ntohs(server_addr.sin_port),[m
[32m+[m[32m                sockfd);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Send elected message[m
[32m+[m[32m    if (!write_u8(conn->writer, MESSAGE_ELECTED)) {[m
[32m+[m[32m        std::cerr << "ERROR 1" << std::endl;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!write_u32(conn->writer, electedServer.ip)) {[m
[32m+[m[32m        std::cerr << "ERROR 2" << std::endl;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!write_u16(conn->writer, electedServer.port)) {[m
[32m+[m[32m        std::cerr << "ERROR 3" << std::endl;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    // Flush writer[m
[32m+[m[32m    if (!flush(conn->writer)) {[m
[32m+[m[32m        std::cerr << "ERROR 4" << std::endl;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
 [m
[31m-void receiveElectedMessage(metadata_t& metadata, server_t& currentServer, server_t& electedServer){[m
[31m-    if(currentServer.ip == electedServer.ip && currentServer.port == electedServer.port){[m
[31m-        std::cerr<<"election finished ";[m
[31m-        printServer(electedServer);[m
[32m+[m[32m/*[m
[32m+[m[32m * Updates state to acknoleadge that the current server is the primary[m
[32m+[m[32m */[m
[32m+[m[32mvoid setElected() {[m
[32m+[m[32m    // Ignore concurrent election results[m
[32m+[m[32m    server_t *current_server = get_current_server();[m
[32m+[m[32m    if (current_server->server_type == primary) {[m
         return;[m
     }[m
[31m-    updateElected(currentServer, electedServer);[m
[31m-    server_t nextServer = getNextServer(metadata, currentServer);[m
[31m-    sendElectedMessage(nextServer, electedServer);[m
[32m+[m
[32m+[m[32m    // Remove the primary server from the ring[m
[32m+[m[32m    // INTERNAL: this changes the ring order![m
[32m+[m[32m    metadata_t *metadata = acquire_metadata();[m
[32m+[m[32m    // INTERNAL: Metadata critical section[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int i = metadata->servers.size()-1; i >=0; ){[m
[32m+[m[32m            if (metadata->servers[i].server_type == primary){[m
[32m+[m[32m                std::swap(metadata->servers[i], metadata->servers[metadata->servers.size()-1]);[m
[32m+[m[32m                metadata->servers.pop_back();[m
[32m+[m[32m                i--;[m
[32m+[m[32m            }[m
[32m+[m[32m            i--;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Update the current server to primary[m
[32m+[m[32m        server_t *current_server = get_current_server();[m
[32m+[m[32m        current_server->server_type = primary;[m
[32m+[m[32m        for (int i = 0; i < metadata->servers.size(); i++) {[m
[32m+[m[32m            if (metadata->servers[i].ip == current_server->ip && metadata->servers[i].port == current_server->port) {[m
[32m+[m[32m                metadata->servers[i].server_type = primary;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    release_metadata();[m
[32m+[m
[32m+[m[32m    // TODO - Didio: client stuff (update connection and such)[m
 }[m
 [m
[31m-void setElected(metadata_t& metadata, server_t& electedServer){[m
[32m+[m[32m/*[m
[32m+[m[32m * Connect to the elected server and get updated metadata[m
[32m+[m[32m */[m
[32m+[m[32mbool updateElected(server_t electedServer) {[m
[32m+[m[32m    // Connect to the elected server[m
[32m+[m[32m    connection_t *conn;[m
[32m+[m[32m    {[m
[32m+[m[32m        // Setup[m
[32m+[m[32m        struct sockaddr_in server_addr;[m
[32m+[m[32m        server_addr.sin_family = AF_INET;[m
[32m+[m[32m        server_addr.sin_port = htons(electedServer.port+2);[m
[32m+[m[32m        server_addr.sin_addr = { electedServer.ip };[m
[32m+[m[32m        bzero(&server_addr.sin_zero, 8);[m
[32m+[m
[32m+[m[32m        // Create socket[m
[32m+[m[32m        int sockfd = socket(AF_INET, SOCK_STREAM, 0);[m
[32m+[m[32m        if (sockfd == -1) {[m
[32m+[m[32m            std::cerr << "ERROR: [Election connection init 1] Could not create the socket" << std::endl;[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Connect[m
[32m+[m[32m        int connect_response = connect(sockfd, (struct sockaddr *) (&server_addr), sizeof(struct sockaddr_in));[m
[32m+[m[32m        if (connect_response < 0) {[m
[32m+[m[32m            std::cerr << "ERROR: [Election connection init 1] Could not connect to the server" << std::endl;[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Create connection object[m
[32m+[m[32m        // INTERNAL: the client's fields are set to the server's fields on purpose[m
[32m+[m[32m        // TODO - Didio: figure out how to get client's IP and port[m
[32m+[m[32m        conn = conn_new([m
[32m+[m[32m                server_addr.sin_addr,[m
[32m+[m[32m                ntohs(server_addr.sin_port),[m
[32m+[m[32m                server_addr.sin_addr,[m
[32m+[m[32m                ntohs(server_addr.sin_port),[m
[32m+[m[32m                sockfd);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Execute request[m
[32m+[m[32m    request_t request = { .type = req_fetch_metadata };[m
[32m+[m[32m    response_t response;[m
[32m+[m[32m    if (!_coms_sync_execute_request(&conn->reader, &conn->writer, request, &response)) {[m
[32m+[m[32m        // Catch network errors[m
[32m+[m[32m        std::cerr << "ERROR 100" << std::endl;[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Catch logic errors[m
[32m+[m[32m    if (response.status != 0) {[m
[32m+[m[32m        std::cerr << "ERROR 101" << std::endl;[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
 [m
[31m-    for(int i = metadata.servers.size(); i >=0; ){[m
[31m-        if(metadata.servers[i].server_type == primary){[m
[31m-            metadata.servers.pop_back();[m
[31m-            i-=2;[m
[31m-            continue;[m
[32m+[m[32m    // Handle response[m
[32m+[m[32m    metadata_t *metadata = acquire_metadata();[m
[32m+[m[32m    // Critical section[m
[32m+[m[32m    {[m
[32m+[m[32m        response.metadata.servers.clear();[m
[32m+[m[32m        for (auto server : metadata->servers) {[m
[32m+[m[32m            response.metadata.servers.push_back(server);[m
         }[m
[31m-        i--;[m
     }[m
[32m+[m[32m    release_metadata();[m
 [m
[31m-    // TODO [m
[31m-    // ver qual erro que dÃ¡[m
[31m-    electedServer.server_type = primary;[m
[32m+[m[32m    // Close the connection and free the allocated memory[m
[32m+[m[32m    close(conn->sockfd);[m
[32m+[m[32m    conn_free(conn);[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**************************************\[m
[32m+[m[32m*                                      *[m
[32m+[m[32m*       Inbound message handling       *[m
[32m+[m[32m*                                      *[m
[32m+[m[32m\**************************************/[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m * Inbound election message handler[m
[32m+[m[32m */[m
[32m+[m[32mvoid handle_async_election_message(server_t winningServer) {[m
[32m+[m[32m    server_t *currentServer = get_current_server();[m
[32m+[m[32m    // Get next server[m
[32m+[m[32m    server_t nextServer = getNextServer(*currentServer);[m
[32m+[m[32m    // Check if the message has reached the highest id server[m
[32m+[m[32m    if(server_eq(currentServer, &winningServer)) {[m
[32m+[m[32m        setElected();[m
[32m+[m[32m        return sendElectedMessage(nextServer, *currentServer);[m
[32m+[m[32m    }[m
[32m+[m[32m    // Check if the current server has higher id then the winning server[m
[32m+[m[32m    if(comp(*currentServer, winningServer)) {[m
[32m+[m[32m        return sendElectionMessage(nextServer, *currentServer);[m
[32m+[m[32m    } else {[m
[32m+[m[32m        return sendElectionMessage(nextServer, winningServer);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
 [m
[31m-    printServer(electedServer);    [m
[32m+[m[32m/*[m
[32m+[m[32m * Inbound elected message handler[m
[32m+[m[32m */[m
[32m+[m[32mvoid handle_async_elected_message(server_t electedServer){[m
[32m+[m[32m    server_t *currentServer = get_current_server();[m
[32m+[m[32m    std::cerr << "[Election] election finished (";[m
[32m+[m[32m    printServer(std::cerr, electedServer);[m
[32m+[m[32m    std::cerr << ")" << std::endl;[m
[32m+[m[32m    // Check if the current server is the elected server (election is concluded) and forward the message if it isn't[m
[32m+[m[32m    if (!server_eq(currentServer, &electedServer)) {[m
[32m+[m[32m        // Update the current server's metadata with the elected server's metadata[m
[32m+[m[32m        updateElected(electedServer);[m
[32m+[m[32m        // Get the next server[m
[32m+[m[32m        server_t nextServer = getNextServer(*currentServer);[m
[32m+[m[32m        // Send elected message to the next server[m
[32m+[m[32m        sendElectedMessage(nextServer, electedServer);[m
[32m+[m[32m    }[m
 }[m
 [m
[31m-void printServer(const server_t& server){[m
[31m-    std::cerr<<server.ip<<' '<<server.port<<' '<<server.server_type<<'\n';[m
[32m+[m[32m/*[m
[32m+[m[32m * Structure that holds data that is sent when the election thread is created[m
[32m+[m[32m */[m
[32m+[m[32mtypedef struct {[m
[32m+[m[32m    int listen_sockfd;[m
[32m+[m[32m    struct sockaddr_in server_address;[m
[32m+[m[32m} el_listener_arguments_t;[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m * Thread that handles election messages[m
[32m+[m[32m */[m
[32m+[m[32mvoid *election_listener_thread(void *args) {[m
[32m+[m[32m    // Disassemble arguments[m
[32m+[m[32m    el_listener_arguments_t *arguments = (el_listener_arguments_t*) args;[m
[32m+[m[32m    struct sockaddr_in server_address = arguments->server_address;[m
[32m+[m[32m    int listen_sockfd = arguments->listen_sockfd;[m
[32m+[m
[32m+[m[32m    // Declare variables[m
[32m+[m[32m    int connection_sockfd;[m
[32m+[m[32m    struct sockaddr_in client_address;[m
[32m+[m[32m    socklen_t client_length;[m
[32m+[m[32m    uint8_t request;[m
[32m+[m[32m    server_t server;[m
[32m+[m
[32m+[m[32m    // Initialize variables[m
[32m+[m[32m    client_length = sizeof(struct sockaddr_in);[m
[32m+[m
[32m+[m[32m    // Listen for clients[m
[32m+[m[32m    // INTERNAL: on error, close the connection and continue accepting clients, the client is responsible for handling errors[m
[32m+[m[32m    while (!should_stop()) {[m
[32m+[m[32m        // Accept a connection[m
[32m+[m[32m        connection_sockfd = accept(listen_sockfd, (struct sockaddr *) &client_address, &client_length);[m
[32m+[m[32m        if (connection_sockfd == -1) {[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Register the connection to the sigint handler[m
[32m+[m[32m        add_connection(connection_sockfd);[m
[32m+[m
[32m+[m[32m        // Create connection object[m
[32m+[m[32m        connection_t *conn = conn_new([m
[32m+[m[32m                server_address.sin_addr,[m
[32m+[m[32m                ntohs(server_address.sin_port),[m
[32m+[m[32m                client_address.sin_addr,[m
[32m+[m[32m                ntohs(client_address.sin_port),[m
[32m+[m[32m                connection_sockfd);[m
[32m+[m
[32m+[m[32m        // Read message[m
[32m+[m[32m        if (!read_u8(conn->reader, &request)) {[m
[32m+[m[32m            fprintf(stderr, "Could not read request from election thread!\n");[m
[32m+[m[32m            close(conn->sockfd);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!read_u32(conn->reader, &server.ip)) {[m
[32m+[m[32m            fprintf(stderr, "Could not read ip from election thread!\n");[m
[32m+[m[32m            close(conn->sockfd);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!read_u16(conn->reader, &server.port)) {[m
[32m+[m[32m            fprintf(stderr, "Could not read port from election thread!\n");[m
[32m+[m[32m            pthread_exit(NULL);[m
[32m+[m[32m            close(conn->sockfd);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Call the appropriate handler[m
[32m+[m[32m        if (request == 10) {[m
[32m+[m[32m            handle_async_election_message(server);[m
[32m+[m[32m        } else if (request == 20) {[m
[32m+[m[32m            handle_async_elected_message(server);[m
[32m+[m[32m        } else {[m
[32m+[m[32m            fprintf(stderr, "Read unknown request (%d)", (uint32_t) request);[m
[32m+[m[32m            close(conn->sockfd);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    close(listen_sockfd);[m
[32m+[m[32m    pthread_exit(NULL);[m
[32m+[m[32m    return NULL;[m[41m [m
 }[m
 [m
[31m-void initiateElection(){[m
[31m-    metadata_t metadata = GetMetadata();[m
[31m-    //how to find myself?[m
[31m-    //TODO[m
[31m-    server_t currentServer;[m
[31m-    server_t targetServer = getNextServer(metadata, currentServer);[m
[31m-    sendElectionMessage(targetServer, currentServer);[m
[32m+[m[32mbool el_start_thread() {[m
[32m+[m[32m    server_t *current_server = get_current_server();[m
[32m+[m
[32m+[m[32m    int listen_sockfd;[m
[32m+[m[32m    int connection_sockfd;[m
[32m+[m[32m    socklen_t client_length;[m
[32m+[m[32m    struct sockaddr_in server_address;[m
[32m+[m[32m    struct sockaddr_in client_address;[m
[32m+[m
[32m+[m[32m    // Initialize the socket[m
[32m+[m[32m    listen_sockfd = socket(AF_INET, SOCK_STREAM, 0);[m
[32m+[m[32m    if (listen_sockfd == -1) {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Bind the socket[m
[32m+[m[32m    server_address.sin_family = AF_INET;[m
[32m+[m[32m    server_address.sin_port = htons(current_server->port+1);[m
[32m+[m[32m    server_address.sin_addr.s_addr = INADDR_ANY;[m
[32m+[m[32m    bzero(&(server_address.sin_zero), 8);[m
[32m+[m
[32m+[m[32m    if (bind(listen_sockfd, (struct sockaddr *) &server_address, sizeof(server_address)) < 0) {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
 [m
[32m+[m[32m    // Setup listen queue[m
[32m+[m[32m    listen(listen_sockfd, 5);[m
 [m
[32m+[m[32m    // Register server socket into the closeable connection list[m
[32m+[m[32m    add_connection(listen_sockfd);[m
 [m
[32m+[m[32m    // Prepare arguments for the thread[m
[32m+[m[32m    el_listener_arguments_t *arguments = (el_listener_arguments_t*) malloc(sizeof(el_listener_arguments_t));[m
[32m+[m[32m    if (arguments == NULL) {[m
[32m+[m[32m        fprintf(stderr, "ERROR: Failed to allocate memory for listener_arguments_t (errno = %d) [at file \"" __FILE__ "\", line %d]\n", errno, __LINE__-2);[m
[32m+[m[32m        exit(EXIT_FAILURE);[m
[32m+[m[32m    }[m
[32m+[m[32m    *arguments = {[m
[32m+[m[32m        .listen_sockfd = listen_sockfd,[m
[32m+[m[32m        .server_address = server_address,[m
[32m+[m[32m    };[m
 [m
[32m+[m[32m    // Create the thread[m
[32m+[m[32m    pthread_t thread;[m
[32m+[m[32m    pthread_create(&thread, NULL, election_listener_thread, &arguments);[m
[32m+[m[32m    return true;[m
 }[m
[41m+[m
[1mdiff --git a/server/src/main.cpp b/server/src/main.cpp[m
[1mindex 96d9bdf..7e270d2 100644[m
[1m--- a/server/src/main.cpp[m
[1m+++ b/server/src/main.cpp[m
[36m@@ -1,3 +1,4 @@[m
[32m+[m[32m#include <complex>[m
 #include <cstddef>[m
 #include <cstdio>[m
 #include <cstdlib>[m
[36m@@ -15,11 +16,13 @@[m
 #include "../include/closeable.h"[m
 #include "../include/client.h"[m
 #include "../include/election.h"[m
[32m+[m[32m#include "../include/coms.h"[m
 [m
 typedef struct {[m
[31m-    /************************************************\[m
[31m-    * The port on which the server will be listening *[m
[31m-    \************************************************/[m
[32m+[m[32m    /*******************************************************\[m
[32m+[m[32m    * The ip and port on which the server will be listening *[m
[32m+[m[32m    \*******************************************************/[m
[32m+[m[32m    uint32_t ip;[m
     uint16_t port;[m
 [m
     /***********************************\[m
[36m@@ -35,47 +38,166 @@[m [mtypedef struct {[m
 } arguments_t;[m
 [m
 int primary_init(arguments_t arguments) {[m
[31m-    state_init();[m
[31m-    // Servidor de heartbeat + comunicaÃ§Ã£o entre servidores[m
[31m-    coms_server_t server = coms_server_init(arguments.port+1);[m
[32m+[m[32m    std::cerr << "[DEBUG] Starting backup" << std::endl;[m
[32m+[m[32m    state_init(arguments.ip, arguments.port, primary);[m
 [m
[31m-    coms_get_metadata(server);[m
[32m+[m[32m    std::cerr << "[DEBUG] Starting election thread" << std::endl;[m
[32m+[m[32m    el_start_thread();[m
[32m+[m[32m    std::cerr << "[DEBUG] Starting communications thread" << std::endl;[m
[32m+[m[32m    coms_thread_init();[m
 [m
[31m-    // Servidor de arquivos[m
[31m-    tcp_dump_1("0.0.0.0", arguments.port);[m
[32m+[m[32m    std::cerr << "[DEBUG] Idle" << std::endl;[m
[32m+[m[32m    while (true) { }[m
 [m
     return EXIT_FAILURE;[m
[31m-    /*[m
[31m-    client_init();[m
[31m-[m
[31m-    signal(SIGINT, sigint_handler);[m
[31m-    signal(SIGPIPE, sigpipe_handler);[m
[31m-    uint16_t port = 4000;[m
[31m-    if (argc >= 2) {[m
[31m-        std::string s(argv[1]);[m
[31m-        std::istringstream iss(s);[m
[31m-        iss >> port;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool initial_handshake(server_t primary_server) {[m
[32m+[m[32m    std::cerr << "[DEBUG] Starting handshake" << std::endl;[m
[32m+[m[32m    // Connect to the elected server[m
[32m+[m[32m    connection_t *conn;[m
[32m+[m[32m    {[m
[32m+[m[32m        // Setup[m
[32m+[m[32m        std::cerr << "[DEBUG] Seting up sockets" << std::endl;[m
[32m+[m[32m        struct sockaddr_in server_addr;[m
[32m+[m[32m        server_addr.sin_family = AF_INET;[m
[32m+[m[32m        server_addr.sin_port = htons(primary_server.port + 2);[m
[32m+[m[32m        server_addr.sin_addr = { primary_server.ip };[m
[32m+[m[32m        bzero(&server_addr.sin_zero, 8);[m
[32m+[m
[32m+[m[32m        // Create socket[m
[32m+[m[32m        std::cerr << "[DEBUG] Creating socket" << std::endl;[m
[32m+[m[32m        int sockfd = socket(AF_INET, SOCK_STREAM, 0);[m
[32m+[m[32m        if (sockfd == -1) {[m
[32m+[m[32m            std::cerr << "ERROR: [Election connection init 1a] Could not create the socket" << std::endl;[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Connect[m
[32m+[m[32m        std::cerr << "[DEBUG] Connecting to primary" << std::endl;[m
[32m+[m[32m        int connect_response = connect(sockfd, (struct sockaddr *) (&server_addr), sizeof(struct sockaddr_in));[m
[32m+[m[32m        if (connect_response < 0) {[m
[32m+[m[32m            std::cerr << "ERROR: [Election connection init 1a] Could not connect to the server" << std::endl;[m
[32m+[m[32m            close(sockfd);[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        add_connection(sockfd);[m
[32m+[m
[32m+[m[32m        // Create connection object[m
[32m+[m[32m        // INTERNAL: the client's fields are set to the server's fields on purpose[m
[32m+[m[32m        // TODO - Didio: figure out how to get client's IP and port[m
[32m+[m[32m        std::cerr << "[DEBUG] Connecting connection object" << std::endl;[m
[32m+[m[32m        conn = conn_new([m
[32m+[m[32m                server_addr.sin_addr,[m
[32m+[m[32m                ntohs(server_addr.sin_port),[m
[32m+[m[32m                server_addr.sin_addr,[m
[32m+[m[32m                ntohs(server_addr.sin_port),[m
[32m+[m[32m                sockfd);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Execute hello request[m
[32m+[m[32m    {[m
[32m+[m[32m        std::cerr << "[DEBUG] Sending hello message" << std::endl;[m
[32m+[m[32m        request_t request = { .type = req_hello };[m
[32m+[m[32m        response_t response;[m
[32m+[m[32m        if (!_coms_sync_execute_request(&conn->reader, &conn->writer, request, &response)) {[m
[32m+[m[32m            // Catch network errors[m
[32m+[m[32m            std::cerr << "ERROR 100a" << std::endl;[m
[32m+[m[32m            std::cerr << "[DEBUG] Closing connection" << std::endl;[m
[32m+[m[32m            close(conn->sockfd);[m
[32m+[m[32m            std::cerr << "[DEBUG] Freeing connection" << std::endl;[m
[32m+[m[32m            conn_free(conn);[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Catch logic errors[m
[32m+[m[32m        if (response.status != 0) {[m
[32m+[m[32m            std::cerr << "ERROR 101a" << std::endl;[m
[32m+[m[32m            std::cerr << "[DEBUG] Closing connection" << std::endl;[m
[32m+[m[32m            close(conn->sockfd);[m
[32m+[m[32m            std::cerr << "[DEBUG] Freeing connection" << std::endl;[m
[32m+[m[32m            conn_free(conn);[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    {[m
[32m+[m[32m        std::cerr << "[DEBUG] Sending metadata message" << std::endl;[m
[32m+[m[32m        request_t request = { .type = req_fetch_metadata };[m
[32m+[m[32m        response_t response;[m
[32m+[m[32m        if (!_coms_sync_execute_request(&conn->reader, &conn->writer, request, &response)) {[m
[32m+[m[32m            // Catch network errors[m
[32m+[m[32m            std::cerr << "ERROR 100b" << std::endl;[m
[32m+[m[32m            std::cerr << "[DEBUG] Closing connection" << std::endl;[m
[32m+[m[32m            close(conn->sockfd);[m
[32m+[m[32m            std::cerr << "[DEBUG] Freeing connection" << std::endl;[m
[32m+[m[32m            conn_free(conn);[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Catch logic errors[m
[32m+[m[32m        if (response.status != 0) {[m
[32m+[m[32m            std::cerr << "ERROR 101b" << std::endl;[m
[32m+[m[32m            std::cerr << "[DEBUG] Closing connection" << std::endl;[m
[32m+[m[32m            close(conn->sockfd);[m
[32m+[m[32m            std::cerr << "[DEBUG] Freeing connection" << std::endl;[m
[32m+[m[32m            conn_free(conn);[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Handle response[m
[32m+[m[32m        std::cerr << "[DEBUG] Acquiring metadata" << std::endl;[m
[32m+[m[32m        metadata_t *metadata = acquire_metadata();[m
[32m+[m[32m        // Critical section[m
[32m+[m[32m        {[m
[32m+[m[32m            std::cerr << "[DEBUG] Updating metadata (len = " << response.metadata.servers.size() << ")" << std::endl;[m
[32m+[m[32m            metadata->servers.clear();[m
[32m+[m[32m            for (auto server : response.metadata.servers) {[m
[32m+[m[32m                std::cerr << "aaa: ";[m
[32m+[m[32m                printServer(std::cerr, server);[m
[32m+[m[32m                std::cerr << std::endl;[m
[32m+[m[32m                metadata->servers.push_back(server);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        std::cerr << "[DEBUG] Releasing metadata" << std::endl;[m
[32m+[m[32m        release_metadata();[m
     }[m
 [m
[31m-    tcp_dump_1("0.0.0.0", port);[m
[31m-    */[m
[32m+[m[32m    // Close the connection and free the allocated memory[m
[32m+[m[32m    std::cerr << "[DEBUG] Closing connection" << std::endl;[m
[32m+[m[32m    close(conn->sockfd);[m
[32m+[m[32m    std::cerr << "[DEBUG] Freeing connection" << std::endl;[m
[32m+[m[32m    conn_free(conn);[m
[32m+[m[32m    return true;[m
 }[m
 [m
 int backup_init(arguments_t arguments) {[m
[31m-    return EXIT_FAILURE;[m
[31m-    /*[m
[31m-    client_init();[m
[31m-[m
[31m-    signal(SIGINT, sigint_handler);[m
[31m-    uint16_t port = 4000;[m
[31m-    if (argc >= 2) {[m
[31m-        std::string s(argv[1]);[m
[31m-        std::istringstream iss(s);[m
[31m-        iss >> port;[m
[32m+[m[32m    std::cerr << "[DEBUG] Starting backup" << std::endl;[m
[32m+[m[32m    state_init(arguments.ip, arguments.port, backup);[m
[32m+[m
[32m+[m[32m    std::cerr << "[DEBUG] Starting election thread" << std::endl;[m
[32m+[m[32m    el_start_thread();[m
[32m+[m[32m    std::cerr << "[DEBUG] Starting communications thread" << std::endl;[m
[32m+[m[32m    coms_thread_init();[m
[32m+[m
[32m+[m[32m    server_t primary_server = {[m
[32m+[m[32m        .ip = arguments.next_server_ip,[m
[32m+[m[32m        .port = arguments.next_server_port,[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    std::cerr << "Primary server: ";[m
[32m+[m[32m    printServer(std::cerr, primary_server);[m
[32m+[m[32m    std::cerr << std::endl;[m
[32m+[m
[32m+[m[32m    std::cerr << "[DEBUG] Calling handshake" << std::endl;[m
[32m+[m[32m    if (!initial_handshake(primary_server)) {[m
[32m+[m[32m        std::cerr << "aaaa1" << std::endl;[m
     }[m
 [m
[31m-    tcp_dump_1("0.0.0.0", port);[m
[31m-    */[m
[32m+[m[32m    std::cerr << "[DEBUG] Waiting" << std::endl;[m
[32m+[m[32m    while (true) {}[m
[32m+[m
[32m+[m[32m    return EXIT_FAILURE;[m
 }[m
 [m
 bool check_ip(char *str, uint32_t *ip) {[m
[36m@@ -108,64 +230,53 @@[m [mbool check_port(char *str, uint16_t *port) {[m
 int main(int argc, char **argv) {[m
     arguments_t arguments;[m
 [m
[31m-    // This isn't a great way of getting the arguments, but it gets the job done[m
[31m-    if (argc >= 2) {[m
[31m-        if (check_port(argv[1], &arguments.port)) {[m
[31m-            if (argc >= 3) {[m
[31m-                if (strcmp(argv[2], "p") == 0) {[m
[31m-                    if (argc == 3) {[m
[31m-                        return primary_init(arguments);[m
[31m-                    } else {[m
[31m-                        fprintf(stderr, "ERRO: excesso de argumentos!\n");[m
[31m-                        fprintf(stderr, "\n");[m
[31m-                        fprintf(stderr, "Uso correto: %s <porta do servidor> p\n", argv[0]);[m
[31m-                        return EXIT_FAILURE;[m
[31m-                    }[m
[31m-                } else if (strcmp(argv[2], "b") == 0) {[m
[31m-                    if (argc >= 4) {[m
[31m-                        if (check_ip(argv[3], &arguments.next_server_ip)) {[m
[31m-                            fprintf(stderr, "addr1 = %x\n", arguments.next_server_ip);[m
[31m-                            if (argc >= 5) {[m
[31m-                                if (check_port(argv[4], &arguments.next_server_port)) {[m
[31m-                                    return backup_init(arguments);[m
[31m-                                } else {[m
[31m-                                    fprintf(stderr, "ERRO: \"%s\" nao eh um valor valido para a porta do primario!\n", argv[3]);[m
[31m-                                    fprintf(stderr, "\n");[m
[31m-                                    fprintf(stderr, "Uso correto: %s <porta do servidor> b <ip do primario> <porta do primario>\n", argv[0]);[m
[31m-                                    return EXIT_FAILURE;[m
[31m-                                }[m
[31m-                            }[m
[31m-                        } else {[m
[31m-                            fprintf(stderr, "ERRO: \"%s\" nao eh um valor valido para o IP do primario!\n", argv[3]);[m
[31m-                            fprintf(stderr, "\n");[m
[31m-                            fprintf(stderr, "Uso correto: %s <porta do servidor> b <ip do primario> <porta do primario>\n", argv[0]);[m
[31m-                            return EXIT_FAILURE;[m
[31m-                        }[m
[31m-                    } else {[m
[31m-                        fprintf(stderr, "Uso correto: %s <porta do servidor> b <ip do primario> <porta do primario>\n", argv[0]);[m
[31m-                        return EXIT_FAILURE;[m
[31m-                    }[m
[31m-                } else {[m
[31m-                    fprintf(stderr, "ERRO: \"%s\" nao eh um valor valido para o tipo de servidor, utilize 'p' ou 'b'!\n", argv[2]);[m
[31m-                    fprintf(stderr, "\n");[m
[31m-                    fprintf(stderr, "Uso correto: %s <porta do servidor> p\n", argv[0]);[m
[31m-                    fprintf(stderr, "Uso correto: %s <porta do servidor> b <ip do primario> <porta do primario>\n", argv[0]);[m
[31m-                    return EXIT_FAILURE;[m
[31m-                }[m
[31m-            } else {[m
[31m-                fprintf(stderr, "Uso correto: %s <porta do servidor> p\n", argv[0]);[m
[31m-                fprintf(stderr, "Uso correto: %s <porta do servidor> b <ip do primario> <porta do primario>\n", argv[0]);[m
[31m-            }[m
[31m-        } else {[m
[31m-            fprintf(stderr, "ERRO: \"%s\" nao eh um valor valido para a porta do servidor!\n", argv[1]);[m
[31m-            fprintf(stderr, "\n");[m
[31m-            fprintf(stderr, "Uso correto: %s <porta do servidor> p\n", argv[0]);[m
[31m-            fprintf(stderr, "Uso correto: %s <porta do servidor> b <ip do primario> <porta do primario>\n", argv[0]);[m
[32m+[m[32m    if (argc < 2) {[m
[32m+[m[32m        fprintf(stderr, "Uso correto: %s p <ip do servidor> <porta do servidor>\n", argv[0]);[m
[32m+[m[32m        fprintf(stderr, "Uso correto: %s b <ip do servidor> <porta do servidor> <ip do primario> <porta do primario>\n", argv[0]);[m
[32m+[m[32m        return EXIT_FAILURE;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (strcmp(argv[1], "p") == 0) {[m
[32m+[m[32m        if (argc != 4) {[m
[32m+[m[32m            fprintf(stderr, "Uso correto: %s p <ip do servidor> <porta do servidor>\n", argv[0]);[m
             return EXIT_FAILURE;[m
         }[m
[32m+[m[32m        if (!check_ip(argv[2], &arguments.ip)) {[m
[32m+[m[32m            fprintf(stderr, "Uso correto: %s p <ip do servidor> <porta do servidor>\n", argv[0]);[m
[32m+[m[32m            return EXIT_FAILURE;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!check_port(argv[3], &arguments.port)) {[m
[32m+[m[32m            fprintf(stderr, "Uso correto: %s p <ip do servidor> <porta do servidor>\n", argv[0]);[m
[32m+[m[32m            return EXIT_FAILURE;[m
[32m+[m[32m        }[m
[32m+[m[32m        return primary_init(arguments);[m
[32m+[m[32m    } else if (strcmp(argv[1], "b") == 0) {[m
[32m+[m[32m        if (argc != 6) {[m
[32m+[m[32m            fprintf(stderr, "Uso correto: %s b <ip do servidor> <porta do servidor> <ip do primario> <porta do primario>\n", argv[0]);[m
[32m+[m[32m            return EXIT_FAILURE;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!check_ip(argv[2], &arguments.ip)) {[m
[32m+[m[32m            fprintf(stderr, "Uso correto: %s b <ip do servidor> <porta do servidor> <ip do primario> <porta do primario>\n", argv[0]);[m
[32m+[m[32m            return EXIT_FAILURE;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!check_port(argv[3], &arguments.port)) {[m
[32m+[m[32m            fprintf(stderr, "Uso correto: %s b <ip do servidor> <porta do servidor> <ip do primario> <porta do primario>\n", argv[0]);[m
[32m+[m[32m            return EXIT_FAILURE;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!check_ip(argv[4], &arguments.next_server_ip)) {[m
[32m+[m[32m            fprintf(stderr, "Uso correto: %s b <ip do servidor> <porta do servidor> <ip do primario> <porta do primario>\n", argv[0]);[m
[32m+[m[32m            return EXIT_FAILURE;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!check_port(argv[5], &arguments.next_server_port)) {[m
[32m+[m[32m            fprintf(stderr, "Uso correto: %s b <ip do servidor> <porta do servidor> <ip do primario> <porta do primario>\n", argv[0]);[m
[32m+[m[32m            return EXIT_FAILURE;[m
[32m+[m[32m        }[m
[32m+[m[32m        return backup_init(arguments);[m
     } else {[m
[31m-        fprintf(stderr, "Uso correto: %s <porta do servidor> p\n", argv[0]);[m
[31m-        fprintf(stderr, "Uso correto: %s <porta do servidor> b <ip do primario> <porta do primario>\n", argv[0]);[m
[32m+[m[32m        fprintf(stderr, "Uso correto: %s p <ip do servidor> <porta do servidor>\n", argv[0]);[m
[32m+[m[32m        fprintf(stderr, "Uso correto: %s b <ip do servidor> <porta do servidor> <ip do primario> <porta do primario>\n", argv[0]);[m
         return EXIT_FAILURE;[m
     }[m
[32m+[m
 }[m
[41m+[m
[1mdiff --git a/server/src/state.cpp b/server/src/state.cpp[m
[1mindex 5ba9132..26c4422 100644[m
[1m--- a/server/src/state.cpp[m
[1m+++ b/server/src/state.cpp[m
[36m@@ -11,9 +11,24 @@[m [mvoid state_init(uint32_t ip, uint16_t port, server_type_t type) {[m
         .server_type = type[m
     };[m
 [m
[32m+[m[32m    state.metadata.servers.push_back(state.current_server);[m
[32m+[m
[32m+[m[32m    state.should_stop = false;[m
[32m+[m
     sem_init(&state.coms_server_mutex, 0, 1);[m
[32m+[m[32m    sem_init(&state.metadata_mutex, 0, 1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/*************\[m
[32m+[m[32m* Should stop *[m
[32m+[m[32m\*************/[m
[32m+[m[32mbool should_stop() {[m
[32m+[m[32m    return state.should_stop;[m
 }[m
 [m
[32m+[m[32m/*************\[m
[32m+[m[32m* Coms server *[m
[32m+[m[32m\*************/[m
 coms_server_t *acquire_coms_server() {[m
     sem_wait(&state.coms_server_mutex);[m
     return &state.coms_server;[m
[36m@@ -27,7 +42,42 @@[m [mvoid set_coms_server(coms_server_t *coms_server) {[m
     state.coms_server = *coms_server;[m
 }[m
 [m
[32m+[m[32m/****************\[m
[32m+[m[32m* Current server *[m
[32m+[m[32m\****************/[m
 server_t *get_current_server() {[m
     return &state.current_server;[m
 }[m
 [m
[32m+[m[32mserver_t *get_primary_server() {[m
[32m+[m[32m    metadata_t *metadata = acquire_metadata();[m
[32m+[m[32m    for (server_t server : metadata->servers) {[m
[32m+[m[32m        state.primary_server = server;[m
[32m+[m[32m        release_metadata();[m
[32m+[m[32m        return &state.primary_server;[m
[32m+[m[32m    }[m
[32m+[m[32m    release_metadata();[m
[32m+[m[32m    return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**********\[m
[32m+[m[32m* Metadata *[m
[32m+[m[32m\**********/[m
[32m+[m[32mmetadata_t *acquire_metadata() {[m
[32m+[m[32m    std::cerr << "[DEBUG] [State] Acquiring metadata" << std::endl;[m
[32m+[m[32m    sem_wait(&state.metadata_mutex);[m
[32m+[m[32m    std::cerr << "[DEBUG] [State] Metadata acquired" << std::endl;[m
[32m+[m[32m    return &state.metadata;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid release_metadata() {[m
[32m+[m[32m    std::cerr << "(metadata) [ ";[m
[32m+[m[32m    for (auto server : state.metadata.servers) {[m
[32m+[m[32m        printServer(std::cerr, server);[m
[32m+[m[32m        std::cerr << ", ";[m
[32m+[m[32m    }[m
[32m+[m[32m    std::cerr << "]" << std::endl;[m
[32m+[m
[32m+[m[32m    sem_post(&state.metadata_mutex);[m
[32m+[m[32m}[m
[32m+[m
[1mdiff --git a/server/temp.txt b/server/temp.txt[m
[1mindex c38a18d..0ff15bb 100644[m
[1m--- a/server/temp.txt[m
[1m+++ b/server/temp.txt[m
[36m@@ -1,9 +0,0 @@[m
[31m-rm -rf build bin[m
[31m-mkdir -p build[m
[31m-g++ -Wall -g -DTEST_MODE -c src/filesystem.cpp -o build/filesystem.o[m
[31m-g++ -Wall -g -DTEST_MODE -c src/main.cpp -o build/main.o[m
[31m-g++ -Wall -g -DTEST_MODE -c src/network.cpp -o build/network.o[m
[31m-g++ -Wall -g -DTEST_MODE -c src/server.cpp -o build/server.o[m
[31m-mkdir -p bin[m
[31m-g++ -o bin/server  build/filesystem.o  build/main.o  build/network.o  build/server.o[m
[31m-./bin/server[m
[1mdiff --git a/server/test.txt b/server/test.txt[m
[1mdeleted file mode 100644[m
[1mindex 591c820..0000000[m
[1m--- a/server/test.txt[m
[1m+++ /dev/null[m
[36m@@ -1,97 +0,0 @@[m
[31m-Read: G E T   /   H T | GET / HT[m
[31m-Read: P / 1 . 1  [m
[31m- H | P/1.1[m
[31m-H[m
[31m-Read: s t :   l o c a | st: loca[m
[31m-Read: h o s t : 5 4 3 | host:543[m
[31m-Read: 1  [m
[31m- C o n n e | 1[m
[31m-Conne[m
[31m-Read: t i o n :   k e | tion: ke[m
[31m-Read: p - a l i v e  | p-alive[m
[31m-Read: s e c - c h - u | sec-ch-u[m
[31m-Read: :   " C h r o m | : "Chrom[m
[31m-Read: u m " ; v = " 1 | um";v="1[m
[31m-Read: 8 " ,   " G o o | 8", "Goo[m
[31m-Read: l e   C h r o m | le Chrom[m
[31m-Read: " ; v = " 1 1 8 | ";v="118[m
[31m-Read: ,   " N o t = A | , "Not=A[m
[31m-Read: B r a n d " ; v | Brand";v[m
[31m-Read: " 9 9 "  [m
[31m- s e | "99"[m
[31m-se[m
[31m-Read: - c h - u a - m | -ch-ua-m[m
[31m-Read: b i l e :   ? 0 | bile: ?0[m
[31m-Read: [m
[31m- s e c - c h - | [m
[31m-sec-ch-[m
[31m-Read: a - p l a t f o | a-platfo[m
[31m-Read: m :   " L i n u | m: "Linu[m
[31m-Read: "  [m
[31m- U p g r a | "[m
[31m-Upgra[m
[31m-Read: e - I n s e c u | e-Insecu[m
[31m-Read: e - R e q u e s | e-Reques[m
[31m-Read: s :   1  [m
[31m- U s | s: 1[m
[31m-Us[m
[31m-Read: r - A g e n t : | r-Agent:[m
[31m-Read: M o z i l l a / | Mozilla/[m
[31m-Read: . 0   ( X 1 1 ; | .0 (X11;[m
[31m-Read: L i n u x   x 8 | Linux x8[m
[31m-Read: _ 6 4 )   A p p | _64) App[m
[31m-Read: e W e b K i t / | eWebKit/[m
[31m-Read: 3 7 . 3 6   ( K | 37.36 (K[m
[31m-Read: T M L ,   l i k | TML, lik[m
[31m-Read:   G e c k o )   |  Gecko) [m
[31m-Read: h r o m e / 1 1 | hrome/11[m
[31m-Read: . 0 . 0 . 0   S | .0.0.0 S[m
[31m-Read: f a r i / 5 3 7 | fari/537[m
[31m-Read: 3 6  [m
[31m- A c c e | 36[m
[31m-Acce[m
[31m-Read: t :   t e x t / | t: text/[m
[31m-Read: t m l , a p p l | tml,appl[m
[31m-Read: c a t i o n / x | cation/x[m
[31m-Read: t m l + x m l , | tml+xml,[m
[31m-Read: p p l i c a t i | pplicati[m
[31m-Read: n / x m l ; q = | n/xml;q=[m
[31m-Read: . 9 , i m a g e | .9,image[m
[31m-Read: a v i f , i m a | avif,ima[m
[31m-Read: e / w e b p , i | e/webp,i[m
[31m-Read: a g e / a p n g | age/apng[m
[31m-Read: * / * ; q = 0 . | */*;q=0.[m
[31m-Read: , a p p l i c a | ,applica[m
[31m-Read: i o n / s i g n | ion/sign[m
[31m-Read: d - e x c h a n | d-exchan[m
[31m-Read: e ; v = b 3 ; q | e;v=b3;q[m
[31m-Read: 0 . 7  [m
[31m- S e c | 0.7[m
[31m-Sec[m
[31m-Read: F e t c h - S i | Fetch-Si[m
[31m-Read: e :   n o n e  | e: none[m
[31m-Read: S e c - F e t c | Sec-Fetc[m
[31m-Read: - M o d e :   n | -Mode: n[m
[31m-Read: v i g a t e  [m
[31m- | vigate[m
[31m-[m
[31m-Read: e c - F e t c h | ec-Fetch[m
[31m-Read: U s e r :   ? 1 | User: ?1[m
[31m-Read: [m
[31m- S e c - F e t | [m
[31m-Sec-Fet[m
[31m-Read: h - D e s t :   | h-Dest: [m
[31m-Read: o c u m e n t  | ocument[m
[31m-Read: A c c e p t - E | Accept-E[m
[31m-Read: c o d i n g :   | coding: [m
[31m-Read: z i p ,   d e f | zip, def[m
[31m-Read: a t e ,   b r  | ate, br[m
[31m-Read: A c c e p t - L | Accept-L[m
[31m-Read: n g u a g e :   | nguage: [m
[31m-Read: n - U S , e n ; | n-US,en;[m
[31m-Read: = 0 . 9 , p t - | =0.9,pt-[m
[31m-Read: R ; q = 0 . 8 , | R;q=0.8,[m
[31m-Read: t ; q = 0 . 7  | t;q=0.7[m
[31m-Read:  [m
[31m- | [m
[31m-[m
